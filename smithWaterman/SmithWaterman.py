# -*- coding: utf-8 -*-
"""BIO310-HW4-KaanGuney.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UpPYBMGapW5b_peMNVoT8ENUQLIbacnu

# ***BIO 310 HOMEWORK 2***

### ***Name:*** _Kaan Güney Keklikçi_

### ***ID:*** _24986_

### ***PART 1:*** Crime Investigation

******************

> ## ***Answers:***

>> ***->*** First sequence ***(blasted):*** 

>>> ***1)*** I ran the Blast suspect1 Sequence and the resulting amino acid was aplha-s1-casein_precursor. The results also include different forms of casein but this is the top result.

>>> ***2)*** Bos Taurus (cattle) is the origin organism.

>>> ***3)*** I ran the protein in Uniprot. Function of the protein is:

>>>> ***plays an important role in the capacity of milk to transport calcium phosphate.***

>>> ***4)*** No, because casein indeed acts as an antioxdidant activity, an antioxidant is highly unilkely to cause a person's death.

**********************

>> ***->*** Second sequence ***(blasted):*** 

>>> ***1)*** I ran the Blast suspect2 Sequence and the resulting amino acid was alpha-amylase 1 precursor. The results also include different forms of amylase but this is the top result.

>>> ***2)*** Homo Sapiens is the origin organism. (for the top entry). Other possible ancestors include gorilla and chimpanzee.

>>> ***3)*** I ran the protein in Uniprot. Function:

>>>> ***acts as the enzyme that breaks down starch to maltose, which in turn is hydrolyzed to glucose that can then be absorbed by the body.***

>>> ***4)*** No, because enzymes are consisted of naturally produced proteins in our body. Therefore, amylase cannot be guilty.

**********************

>> ***->*** Third sequence ***(blasted):*** 

>>> ***1)*** I ran the Blast suspect3 Sequence and the result was Chain A, Atrolysin C [Crotalus atrox]. (snake venom)

>>> ***2)*** Crotalus atrox(diamondback rattlesnake) is the origin organism.

>>> ***3)*** I ran the protein in Uniprot. Function:

>>>> ***catalysts an enzime that break peptide bonds of nonterminal amino acids (i.e. within the molecule).***

>>> ***4)*** Yes because snake venom breaks down the polypeptides in the body and causes blood cloths. Eventually, it results in the breakdown of respiratory system and severe tissue damage. This leads to a painful death.

**********************

>> ***->*** Fourth sequence ***(blasted):*** 

>>> ***1)*** I ran the Blast suspect4 Sequence and the result was Chain A, Bovine Beta-Lactoglobulin Complexed With Palmitate, Lattice Z [Bos taurus].

>>> ***2)*** Bovine is the origin organism.

>>> ***3)*** I ran the protein in Uniprot. Function:

>>>> ***β-lg has the ability to bind hydrophobic components, for example retinol and long-chain fatty acids.***

>>> ***4)*** No, because β-lg is a regulating whey protein for binding hydrophobic components and especially long-chain fatty acids.

**********************

### ***PART 2:*** Local Alignment

******************

> ## ***Answers:***

>> ***1)*** Starting to implement the algorithm (dynamic programming).
"""


# Commented out IPython magic to ensure Python compatibility.
# navigate to directory 
# %cd "/content/drive/My Drive"

# first, input the .txt extension
seq_index = input("Please enter a number between [1-5]: ")
print()

# sequences to be read 
sequence_1 = ""
sequence_2 = ""

# read the file
# parameters are the inputs given above & sequences
def get_sequences(seq_index,sequence_1,sequence_2):
  f = "test_input" + seq_index + ".txt"
  # read sequences
  with open(f, "r") as f:
    contents = f.read()
    contents = contents.split("\n")
    sequence_1 = '-'+ contents[0]
    sequence_2 = '-'+ contents[1]
    f.close()
  return sequence_1,sequence_2
  
# user inputs scores and penalties -> match, mismatch, gap 
match_score = int(input("Please enter the match score: "))
mismatch_score = int(input("Please enter the mismatch score: "))
gap = int(input("Please enter gap penalty: "))

# get sequences 
sequence_1, sequence_2 = get_sequences(seq_index,sequence_1,sequence_2)

# files read, proceed to the dynamic programming algorithm now...

import numpy as np

ScoreMatrix = []
# pre-compute matrix
# first sequence is rows
# second is columns 
def init_matrix(sequence_1,sequence_2):
  # construct the matrix 
  matrix = []
  temp = []
  rowsize = len(sequence_1) 
  colsize = len(sequence_2)
  for i in range(rowsize):
    for j in range(colsize):
      temp.append(0)
    # add 
    matrix.append(temp)
    # reset
    temp = []
  matrix = np.array(matrix).reshape(rowsize,colsize)
  return matrix

# initial matrix, filled with zeros
ScoreMatrix = init_matrix(sequence_1,sequence_2)

# if negative make it 0
def makeZero(k):
  if k < 0:
    k = 0
  return k

def score_matrix(ScoreMatrix,match_score,mismatch_score,gap,sequence_1,sequence_2):
  # leave the first row,column as zero
  # fill the rest 
  # tabulation method
  rowsize = len(sequence_1) 
  colsize = len(sequence_2) 
  for i in range(1,rowsize):
    for j in range(1,colsize):
      # match
      if(sequence_1[i] == sequence_2[j]):
        ScoreMatrix[i][j] = makeZero(ScoreMatrix[i-1][j-1] + match_score)
      # mismatch or gap 
      else:
        GapScore = max(makeZero(ScoreMatrix[i][j-1] + gap),makeZero(ScoreMatrix[i-1][j] + gap))
        MisMatchScore = makeZero(ScoreMatrix[i-1][j-1] + mismatch_score)
        val = max(GapScore,MisMatchScore)
        ScoreMatrix[i][j] = val
  return ScoreMatrix

# matrix filled w.r.t predefined scores 
ScoreMatrix = score_matrix(ScoreMatrix,match_score,mismatch_score,gap,sequence_1,sequence_2)

import sys # for max element

# find the local alignment 
# store aligned pairs, reverse before printing the result
pairs = []
matrix_score = 0 

def local(ScoreMatrix,sequence_1,sequence_2,pairs):
  rowsize = len(ScoreMatrix)
  colsize = len(ScoreMatrix[0])
  maxElement = -(sys.maxsize)
  locx,locy = 0,0 # location of max element
  for i in range(rowsize):
    for j in range(colsize):
      if(ScoreMatrix[i][j] > maxElement):
        maxElement = ScoreMatrix[i][j]
        locx,locy = i,j
  # backtrack from the largest element 
  while(ScoreMatrix[locx][locy] != 0):
    # constant vertical gaps
    if(locx == 0 and locy != 0):
      pairs.append(['-',sequence_2[locy]])
      locy -= 1
    # constant horizontal gaps
    elif(locx != 0 and locy == 0):
      pairs.append([sequence_1[locx],'-'])
      locx -= 1
    else:
      nextMax = max(ScoreMatrix[locx-1][locy-1],ScoreMatrix[locx][locy-1],ScoreMatrix[locx-1][locy])
      # check if there is a match even if there is a higher score by one of the gap cells 
      checker = False
      # if match
      if(sequence_1[locx] == sequence_2[locy]):
        checker = True
      # prefer match to higher scored gaps, skip next steps
      if(checker and nextMax != ScoreMatrix[locx-1][locy-1]):
        pairs.append([sequence_1[locx],sequence_2[locy]])
        locx -= 1          
        locy -= 1 
        continue
      # come back diagonally 
      if(nextMax == ScoreMatrix[locx-1][locy-1]):
        pairs.append([sequence_1[locx],sequence_2[locy]])
        locx -= 1          
        locy -= 1 
      # horizontal gap
      elif(nextMax == ScoreMatrix[locx-1][locy]):
        pairs.append([sequence_1[locx],'-'])
        locx -=1
      # vertical gap
      else:
        pairs.append(['-',sequence_2[locy]]) 
        locy -= 1

  return pairs, maxElement

# get the alignment and the score 
alignment,matrix_score = local(ScoreMatrix,sequence_1,sequence_2,pairs)

# reorder the alignment 
def reorder(alignment):
  temp = []
  last = len(alignment) - 1
  while(last >= 0):
    temp.append(alignment[last])
    last -= 1
  return temp

# alignment in order
alignment = reorder(alignment)

# write the results into a .txt extension
def write_to_txt(alignment,matrix_score,sequence_1,sequence_2,match_score,mismatch_score,gap,seq_index):
  filename = "Results" + "_input_" + str(seq_index) + ".txt"
  with open(filename,"w+") as f:
    # first write the sequences 
    f.write("Smith-Waterman Algorithm Results\n\nSequence 1: " + sequence_1.strip('-') + "\nSequence 2: " + sequence_2.strip('-') + "\n\n")
    lenres = len(alignment)
    res_upper = ""
    res_mid = ""
    res_lower = ""
    for k in range(lenres):
      # if match 
      if(alignment[k][0] == alignment[k][1]):
        res_upper += str(alignment[k][0])
        res_mid += '|'
        res_lower += str(alignment[k][1])
        continue
      # if gap 
      if(alignment[k][0] == '-' or alignment[k][1] == '-'):
        res_upper += str(alignment[k][0])
        res_mid+= ' '
        res_lower += str(alignment[k][1])
        continue
      # if mismatch 
      else:
        res_upper += str(alignment[k][0])
        res_mid += '.'
        res_lower += str(alignment[k][1])
        
    f.write(res_upper + "\n" + res_mid + "\n" + res_lower + "\n\nScore = %s, Match = %s, Mismatch = %s, Gap = %s." % (matrix_score,match_score,mismatch_score,gap))
    f.close()

# write
write_to_txt(alignment,matrix_score,sequence_1,sequence_2,match_score,mismatch_score,gap,seq_index)

"""> ### ***_I ran my algorithm on the provided test cases:_***

>> ### _MyResults folder ***(included in my submission file)*** contains the outputs on the provided testcases._

>> ### _TestCases folder ***(included in my submission file)*** contains testcases._

> ***Note that for all test cases;***

>> _MatchScore : ***8***_

>> _MisMatch Score : ***-5***_

>> _GapPenalty : ***-3***_


**********************************

### ***PART 3:*** _Hidden Markov Models_

****************************************

### ***Answers***

> _All answers related to this part are in .pdf format in Part3 folder
***(included in my submission file)***._

>> _In these .pdf documents, you may find my handwritten solutions to this question._

**********************************
"""

# HW2 finished...
